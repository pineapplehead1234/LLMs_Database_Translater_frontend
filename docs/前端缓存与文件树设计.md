# 文档翻译前端存储与文件树设计说明

## 1. 整体目标

- 后端通过任务接口返回翻译结果（原文/译文 Markdown + 术语标注）。
- 前端需要：
  - 把**任务结果**缓存到 IndexedDB，支持离线/历史查看。
  - 用一个**文件树**展示“文件夹 + 文件名”，文件节点对应某个任务。
  - 只渲染 **Markdown 文本**，不直接展示原始 md/pdf/docx 文件。
  - 图片资源（`./images/xxx.png`）通过独立接口获取并缓存，用于 Markdown 渲染。

---

## 2. 相关接口与字段角色

### 2.1 提交任务接口

`POST /api/task/upload`

请求体（简化）：

```yaml
file: <上传的原始文件（md / docx / pdf）>
target_lang: <目标语言，例如：中文>
strategy: <翻译策略：fast / normal / thinking>
client_request_id: <客户端请求 ID，由前端指定，一般设为“文件名”>
```

字段说明：

- `client_request_id`
  - 前端生成并传入。
  - 建议规则：**等于文件名**（可以保留扩展名，例如 `report_v1.pdf`）。
  - 用于前端 UI 显示、文件树节点命名。

### 2.2 查询任务结果接口

`GET /api/task/query?task_id=...`

约定返回结构示例（TaskResult）：

```json
{
  "task_id": "045f3a03-9eb8-406c-8fb8-f4736335a532",
  "status": "success",
  "error": null,
  "original_markdown": {
    "1": "# Machine Learning\n\nML is important.",
    "2": "![Diagram](./images/ml.png)"
  },
  "translated_markdown": {
    "1": "# 机器学习\n\n机器学习很重要。",
    "2": "![Diagram](./images/ml.png)"
  },
  "term_annotations": {
    "1": [
      { "term": "Machine Learning", "translation": "机器学习" },
      { "term": "ML", "translation": "机器学习" }
    ],
    "2": []
  },
  "client_request_id": "report_v1.pdf"
}
```

关键字段含义：

- **`task_id`**
  - 后端生成的任务 ID。
  - 用于：
    - 查询任务结果；
    - 下载任务相关图片；
    - 在前端缓存中作为主键。

- **`client_request_id`**
  - 前端在上传时指定。
  - 在结果中回传，前端用它作为“文件名”显示在文件树上。

- **`original_markdown` / `translated_markdown`**
  - 段号 → Markdown 文本。
  - 前端最终渲染的就是这些 Markdown 文本。

- **`term_annotations`**
  - 段号 → 当前段的术语注释列表。
  - 用于 UI 中分段展示术语信息。

---

## 3. IndexedDB 缓存设计

### 3.1 缓存目标

只缓存“后端返回的数据”和“后端返回的资源”：

1. **任务结果 JSON（TaskResult）**
2. **任务图片资源（ZIP 解出来的单张图片 Blob）**
3. **（可选）文件树结构（前端生成，用于持久化用户的文件视图）**

### 3.2 Key 设计（逻辑）

示例逻辑 key 结构：

- **任务结果**
  - Key：`task:{task_id}`
  - Value：整个 TaskResult JSON 原样存储。

- **图片资源**
  - 从 `GET /api/task/download/images?task_id=...` 得到 ZIP 后按文件拆分。
  - Key：`image:{task_id}:{path}`
    - `path` 为 markdown 中使用的逻辑路径，例如：`./images/ml.png`
  - Value：图片 Blob。

- **文件树**
  - 可以用一个单独 key 存整个树（或按项目分开存）：
  - Key：`tree`
  - Value：文件树 JSON（仅包含文件夹 + 文档节点）。

> 注意：IndexedDB 不是真正的“多级文件夹”，只是一张 key→value 表。
> “两层文件夹”是通过**文件树 JSON 的结构**来约束的，而不是 IndexedDB 本身。

---

## 4. 文件树设计

### 4.1 约束与目标

- 只展示：
  - 文件夹（folder）
  - 文档文件节点（file），支持：`md / docx / pdf`
- 图片 **不在文件树中展示**。
- 文件夹最多两层（根节点不算）。

### 4.2 节点数据结构（概念）

统一节点结构（概念上）：

- 公共字段：
  - `id`: 节点唯一 ID
  - `type`: `'folder' | 'file'`
  - `name`: 展示名称
  - `parentId`: 父节点 ID（根节点 parentId = null）
- 对于 `file` 节点额外字段：
  - `taskId`: 对应后端任务的 `task_id`
  - `clientRequestId`: 对应 TaskResult 的 `client_request_id`（通常等于文件名）
  - `docType`: `'md' | 'pdf' | 'docx'`（原始文件类型，用于显示不同图标）

### 4.3 文件名与任务的映射规则

- 每次上传一个文件：
  - 前端设置：`client_request_id = 原始文件名`，例如 `report_v1.pdf`。
  - 后端创建一个新任务，生成 `task_id`。
- 查询任务结果时：
  - 返回 TaskResult，里面包含 `task_id` 和 `client_request_id`。
- 文件树中新建一个 `file` 节点：
  - `name = client_request_id`（展示的文件名）
  - `taskId = task_id`
  - `docType` 来自原始上传文件的扩展名
- **结论：一个任务 = 文件树中的一个文件节点**  
  文件名由 `client_request_id` 决定。

---

## 5. Markdown 与图片路径的处理

### 5.1 Markdown 文本

- 渲染时从 TaskResult 中读取：
  - `original_markdown` 或 `translated_markdown`
- 可以：
  - 按段号顺序拼成一个完整 Markdown 字符串；
  - 或者保留“分段”，一个段块一段块渲染，便于显示对应段落的 `term_annotations`。

### 5.2 图片路径（例如 `./images/ml.png`）

- Markdown 文本中使用的是相对路径，如：`![Diagram](./images/ml.png)`。
- 前端策略：
  1. 调用 `/api/task/download/images?task_id=...` 获取该任务的图片 ZIP。
  2. 解压出单个文件，按 `path` 存入缓存：
     - Key：`image:{task_id}:{path}`，例如：`image:045f...:./images/ml.png`
  3. 渲染 Markdown 时：
     - 解析到 `./images/ml.png` 时，通过 `task_id + path` 从 IndexedDB 读取对应 Blob。
     - 将 Blob 转为 `blob:` URL，并在渲染前把路径替换为该 URL。

- 这样实现：
  - 图片完全基于缓存，不依赖真实磁盘路径。
  - 文件树中不展示图片，只在 Markdown 渲染阶段使用。

---

## 6. 典型前端流程

### 6.1 上传文件

1. 用户选择文件 `report_v1.pdf`。
2. 前端构造上传请求：
   - `file = report_v1.pdf`
   - `client_request_id = "report_v1.pdf"`
3. 发送 `POST /api/task/upload`。

### 6.2 轮询/查询任务结果

1. 后端返回 `task_id`（或通过其它方式拿到）。
2. 前端使用 `GET /api/task/query?task_id=...` 查询直到 `status = "success"`。
3. 得到 TaskResult：
   - 缓存为 `task:{task_id}`。
   - 在文件树插入一个文件节点：
     - `name = client_request_id`
     - `taskId = task_id`
     - `docType` 来源于原始文件扩展名。

### 6.3 打开文件节点

1. 用户在文件树点击某个文件节点。
2. 前端根据节点拿到：
   - `taskId`
   - `clientRequestId`
3. 从缓存中读取 `task:{taskId}` 的 TaskResult：
   - 如果不存在，则调用 `/api/task/query` 拉取一次并写入缓存。
4. 从 TaskResult 中取出：
   - `original_markdown` / `translated_markdown`
   - `term_annotations`
5. 按 UI 需求渲染 Markdown 和术语注释：
   - 根据需要选择显示原文、译文或同时显示。

### 6.4 渲染 Markdown 里的图片

1. 在渲染过程中，解析 Markdown 文本中出现的 `./images/xxx.png`。
2. 组合 key：`image:{taskId}:./images/xxx.png` 去 IndexedDB 查询。
3. 若存在 Blob：
   - 生成 `blob:` URL，将 Markdown 中的路径替换为该 URL。
4. 若不存在：
   - 可触发一次 `/api/task/download/images?task_id=...` 下载并缓存，再重渲染。

---

## 7. 小结

- **任务级缓存**：以 `task_id` 为主键，缓存 TaskResult JSON。
- **文件树展示**：
  - 只有文件夹和文件节点；
  - 每个文件节点对应一个 `task_id`；
  - 文件名使用 `client_request_id`，与用户上传时的文件名一致。
- **图片资源缓存**：
  - 通过 `/download/images` 获取；
  - 以 `image:{task_id}:{路径}` 存储，供 Markdown 渲染时使用。
- **前端渲染**：
  - 不再依赖原始 md/pdf/docx 文件；
  - 统一从 TaskResult 的 Markdown 和术语标注中构建视图。
